---
title: 強烈鼓勵開發指導方針 |Microsoft Docs
ms.custom: ''
ms.date: 09/13/2016
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 4d68a8f3-fba0-44c5-97b9-9fc191d269a5
caps.latest.revision: 13
ms.openlocfilehash: 0906d0d37c66b8c1538a0b2e9e0f1ff2fba12ac0
ms.sourcegitcommit: e7445ba8203da304286c591ff513900ad1c244a4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/23/2019
ms.locfileid: "62067360"
---
# <a name="strongly-encouraged-development-guidelines"></a><span data-ttu-id="98221-102">強烈建議使用的開發指導方針</span><span class="sxs-lookup"><span data-stu-id="98221-102">Strongly Encouraged Development Guidelines</span></span>

<span data-ttu-id="98221-103">本章節描述當您撰寫您的 cmdlet 時，您應該遵循的指導方針。</span><span class="sxs-lookup"><span data-stu-id="98221-103">This section describes guidelines that you should follow when you write your cmdlets.</span></span> <span data-ttu-id="98221-104">分成設計的 cmdlet 和撰寫程式的指令程式碼的指導方針的指導方針。</span><span class="sxs-lookup"><span data-stu-id="98221-104">They are separated into guidelines for designing cmdlets and guidelines for writing your cmdlet code.</span></span> <span data-ttu-id="98221-105">您可能會發現，這些指導方針不是適用於每個案例。</span><span class="sxs-lookup"><span data-stu-id="98221-105">You might find that these guidelines are not applicable for every scenario.</span></span> <span data-ttu-id="98221-106">不過，如果它們會套用，而且您不遵循這些指導方針，您的使用者可能不佳的體驗在使用您的 cmdlet 時。</span><span class="sxs-lookup"><span data-stu-id="98221-106">However, if they do apply and you do not follow these guidelines, your users might have a poor experience when they use your cmdlets.</span></span>

## <a name="design-guidelines"></a><span data-ttu-id="98221-107">設計指導方針</span><span class="sxs-lookup"><span data-stu-id="98221-107">Design Guidelines</span></span>

- [<span data-ttu-id="98221-108">使用一個特定名詞的 Cmdlet 名稱 (SD01)</span><span class="sxs-lookup"><span data-stu-id="98221-108">Use a Specific Noun for a Cmdlet Name (SD01)</span></span>](./strongly-encouraged-development-guidelines.md#use-a-specific-noun-for-a-cmdlet-name-sd01)

- [<span data-ttu-id="98221-109">Cmdlet 名稱 (SD02) 使用 Pascal 大小寫</span><span class="sxs-lookup"><span data-stu-id="98221-109">Use Pascal Case for Cmdlet Names (SD02)</span></span>](./strongly-encouraged-development-guidelines.md#use-pascal-case-for-cmdlet-names-sd02)

- [<span data-ttu-id="98221-110">參數設計指導方針 (SD03)</span><span class="sxs-lookup"><span data-stu-id="98221-110">Parameter Design Guidelines (SD03)</span></span>](./strongly-encouraged-development-guidelines.md#parameter-design-guidelines-sd03)

- [<span data-ttu-id="98221-111">提供意見給使用者 (SD04)</span><span class="sxs-lookup"><span data-stu-id="98221-111">Provide Feedback to the User (SD04)</span></span>](./strongly-encouraged-development-guidelines.md#provide-feedback-to-the-user-sd04)

- [<span data-ttu-id="98221-112">建立 Cmdlet 說明檔 (SD05)</span><span class="sxs-lookup"><span data-stu-id="98221-112">Create a Cmdlet Help File (SD05)</span></span>](./strongly-encouraged-development-guidelines.md#create-a-cmdlet-help-file-sd05)

## <a name="code-guidelines"></a><span data-ttu-id="98221-113">程式碼的指導方針</span><span class="sxs-lookup"><span data-stu-id="98221-113">Code Guidelines</span></span>

- [<span data-ttu-id="98221-114">程式碼參數 (SC01)</span><span class="sxs-lookup"><span data-stu-id="98221-114">Coding Parameters (SC01)</span></span>](./strongly-encouraged-development-guidelines.md#coding-parameters-sc01)

- [<span data-ttu-id="98221-115">支援妥善定義的管線輸入 (SC02)</span><span class="sxs-lookup"><span data-stu-id="98221-115">Support Well Defined Pipeline Input (SC02)</span></span>](./strongly-encouraged-development-guidelines.md#support-well-defined-pipeline-input-sc02)

- [<span data-ttu-id="98221-116">將單一記錄寫入管線 (SC03)</span><span class="sxs-lookup"><span data-stu-id="98221-116">Write Single Records to the Pipeline (SC03)</span></span>](./strongly-encouraged-development-guidelines.md#write-single-records-to-the-pipeline-sc03)

- [<span data-ttu-id="98221-117">讓 Cmdlet 不區分大小寫和保留大小寫 (SC04)</span><span class="sxs-lookup"><span data-stu-id="98221-117">Make Cmdlets Case-Insensitive and Case-Preserving (SC04)</span></span>](./strongly-encouraged-development-guidelines.md#make-cmdlets-case-insensitive-and-case-preserving-sc04)

## <a name="design-guidelines"></a><span data-ttu-id="98221-118">設計指導方針</span><span class="sxs-lookup"><span data-stu-id="98221-118">Design Guidelines</span></span>

<span data-ttu-id="98221-119">設計以確保一致的使用者經驗之間使用您的 cmdlet 和其他 cmdlet 的 cmdlet 時，應該遵循下列指導方針。</span><span class="sxs-lookup"><span data-stu-id="98221-119">The following guidelines should be followed when designing cmdlets to ensure a consistent user experience between using your cmdlets and other cmdlets.</span></span> <span data-ttu-id="98221-120">當您找到適用於您情況的設計指導方針時，請務必查看類似的指導方針中的程式碼的方針。</span><span class="sxs-lookup"><span data-stu-id="98221-120">When you find a Design guideline that applies to your situation, be sure to look at the Code guidelines for similar guidelines.</span></span>

### <a name="use-a-specific-noun-for-a-cmdlet-name-sd01"></a><span data-ttu-id="98221-121">使用一個特定名詞的 Cmdlet 名稱 (SD01)</span><span class="sxs-lookup"><span data-stu-id="98221-121">Use a Specific Noun for a Cmdlet Name (SD01)</span></span>

<span data-ttu-id="98221-122">Cmdlet 命名中使用的名詞，需要有非常明確，讓使用者可以探索您的 cmdlet。</span><span class="sxs-lookup"><span data-stu-id="98221-122">Nouns used in cmdlet naming need to be very specific so that the user can discover your cmdlets.</span></span> <span data-ttu-id="98221-123">泛型的名詞，例如 「 伺服器 」 使用一個精簡版本的產品名稱的前置詞。</span><span class="sxs-lookup"><span data-stu-id="98221-123">Prefix generic nouns such as "server" with a shortened version of the product name.</span></span> <span data-ttu-id="98221-124">比方說，如果名詞指的是正在執行 Microsoft SQL Server 執行個體的伺服器，使用的名詞，例如"SQLServer"。</span><span class="sxs-lookup"><span data-stu-id="98221-124">For example, if a noun refers to a server that is running an instance of Microsoft SQL Server, use a noun such as "SQLServer".</span></span> <span data-ttu-id="98221-125">特定名詞的組合和核准的動詞命令的簡短清單可讓使用者快速探索，並預期功能，同時避免重複的 cmdlet 名稱。</span><span class="sxs-lookup"><span data-stu-id="98221-125">The combination of specific nouns and the short list of approved verbs enable the user to quickly discover and anticipate functionality while avoiding duplication among cmdlet names.</span></span>

<span data-ttu-id="98221-126">若要增強使用者體驗，您選擇的 cmdlet 名稱的名詞應該是單數。</span><span class="sxs-lookup"><span data-stu-id="98221-126">To enhance the user experience, the noun that you choose for a cmdlet name should be singular.</span></span> <span data-ttu-id="98221-127">例如，使用名稱`Get-Process`而非**取得處理序**。</span><span class="sxs-lookup"><span data-stu-id="98221-127">For example, use the name `Get-Process` instead of **Get-Processes**.</span></span> <span data-ttu-id="98221-128">最好的方式是遵循所有的 cmdlet 名稱，此規則，即使指令程式很可能要採取多個項目。</span><span class="sxs-lookup"><span data-stu-id="98221-128">It is best to follow this rule for all cmdlet names, even when a cmdlet is likely to act upon more than one item.</span></span>

### <a name="use-pascal-case-for-cmdlet-names-sd02"></a><span data-ttu-id="98221-129">Cmdlet 名稱 (SD02) 使用 Pascal 大小寫</span><span class="sxs-lookup"><span data-stu-id="98221-129">Use Pascal Case for Cmdlet Names (SD02)</span></span>

<span data-ttu-id="98221-130">參數名稱使用 pascal 命名法大小寫。</span><span class="sxs-lookup"><span data-stu-id="98221-130">Use Pascal case for parameter names.</span></span> <span data-ttu-id="98221-131">換句話說，充分利用動詞和名詞中使用的所有詞彙的第一個字母。</span><span class="sxs-lookup"><span data-stu-id="98221-131">In other words, capitalize the first letter of verb and all terms used in the noun.</span></span> <span data-ttu-id="98221-132">例如，"`Clear-ItemProperty`」。</span><span class="sxs-lookup"><span data-stu-id="98221-132">For example, "`Clear-ItemProperty`".</span></span>

### <a name="parameter-design-guidelines-sd03"></a><span data-ttu-id="98221-133">參數設計指導方針 (SD03)</span><span class="sxs-lookup"><span data-stu-id="98221-133">Parameter Design Guidelines (SD03)</span></span>

<span data-ttu-id="98221-134">指令程式必須在收到它必須在其運作，資料的參數和參數，表示用來判斷作業的特性的資訊。</span><span class="sxs-lookup"><span data-stu-id="98221-134">A cmdlet needs parameters that receive the data on which it must operate, and parameters that indicate information that is used to determine the characteristics of the operation.</span></span> <span data-ttu-id="98221-135">比方說，cmdlet 可能會有`Name`接收資料管線，與此 cmdlet 的參數可能會有`Force`表示執行其作業時，會強制此 cmdlet 的參數。</span><span class="sxs-lookup"><span data-stu-id="98221-135">For example, a cmdlet might have a `Name` parameter that receives data from the pipeline, and the cmdlet might have a `Force` parameter to indicate that the cmdlet can be forced to perform its operation.</span></span> <span data-ttu-id="98221-136">Cmdlet 可以定義的參數數目沒有限制。</span><span class="sxs-lookup"><span data-stu-id="98221-136">There is no limit to the number of parameters that a cmdlet can define.</span></span>

#### <a name="use-standard-parameter-names"></a><span data-ttu-id="98221-137">使用標準的參數名稱</span><span class="sxs-lookup"><span data-stu-id="98221-137">Use Standard Parameter Names</span></span>

<span data-ttu-id="98221-138">您的 cmdlet 應該使用標準的參數名稱，好讓使用者可以快速判斷特定參數的表示。</span><span class="sxs-lookup"><span data-stu-id="98221-138">Your cmdlet should use standard parameter names so that the user can quickly determine what a particular parameter means.</span></span> <span data-ttu-id="98221-139">如果需要更特定的名稱，請使用標準的參數名稱，，，然後指定做為別名的 更為具體的名稱。</span><span class="sxs-lookup"><span data-stu-id="98221-139">If a more specific name is required, use a standard parameter name, and then specify a more specific name as an alias.</span></span> <span data-ttu-id="98221-140">例如， `Get-Service` cmdlet 有一個參數具有泛型名稱 (`Name`) 和更具體的別名 (`ServiceName`)。</span><span class="sxs-lookup"><span data-stu-id="98221-140">For example, the `Get-Service` cmdlet has a  parameter that has a generic name (`Name`) and a more specific alias (`ServiceName`).</span></span> <span data-ttu-id="98221-141">這兩個詞彙可用來指定參數。</span><span class="sxs-lookup"><span data-stu-id="98221-141">Both terms can be used to specify the parameter.</span></span>

<span data-ttu-id="98221-142">如需有關參數名稱和其資料類型的詳細資訊，請參閱[Cmdlet 的參數名稱和功能的指導方針](./standard-cmdlet-parameter-names-and-types.md)。</span><span class="sxs-lookup"><span data-stu-id="98221-142">For more information about parameter names and their data types, see [Cmdlet Parameter Name and Functionality Guidelines](./standard-cmdlet-parameter-names-and-types.md).</span></span>

#### <a name="use-singular-parameter-names"></a><span data-ttu-id="98221-143">使用單數的參數名稱</span><span class="sxs-lookup"><span data-stu-id="98221-143">Use Singular Parameter Names</span></span>

<span data-ttu-id="98221-144">請避免使用複數名稱參數的值是單一項目。</span><span class="sxs-lookup"><span data-stu-id="98221-144">Avoid using plural names for parameters whose value is a single element.</span></span> <span data-ttu-id="98221-145">這包括參數陣列，或清單，因為使用者可能會提供陣列或清單中只有一個元素的清單。</span><span class="sxs-lookup"><span data-stu-id="98221-145">This includes parameters that take arrays or lists because the user might supply an array or list with only one element.</span></span>

<span data-ttu-id="98221-146">只有在這些參數的值是一律多項目值的情況下，應該使用複數的參數名稱。</span><span class="sxs-lookup"><span data-stu-id="98221-146">Plural parameter names should be used only in those cases where the value of the parameter is always a multiple-element value.</span></span> <span data-ttu-id="98221-147">在這些情況下，此指令程式應該確認提供多個項目，且 cmdlet 應該會顯示警告給使用者如果不提供多個項目。</span><span class="sxs-lookup"><span data-stu-id="98221-147">In these cases, the cmdlet should verify that multiple elements are supplied, and the cmdlet should display a warning to the user if multiple elements are not supplied.</span></span>

#### <a name="use-pascal-case-for-parameter-names"></a><span data-ttu-id="98221-148">參數名稱使用 pascal 命名法大小寫</span><span class="sxs-lookup"><span data-stu-id="98221-148">Use Pascal Case for Parameter Names</span></span>

<span data-ttu-id="98221-149">參數名稱使用 pascal 命名法大小寫。</span><span class="sxs-lookup"><span data-stu-id="98221-149">Use Pascal case for parameter names.</span></span> <span data-ttu-id="98221-150">換句話說，將參數名稱，包括名稱的第一個字母中的每個單字的第一個字母的大寫。</span><span class="sxs-lookup"><span data-stu-id="98221-150">In other words, capitalize the first letter of each word in the parameter name, including the first letter of the name.</span></span> <span data-ttu-id="98221-151">例如，參數名稱`ErrorAction`使用正確的大小寫。</span><span class="sxs-lookup"><span data-stu-id="98221-151">For example, the parameter name `ErrorAction` uses the correct capitalization.</span></span> <span data-ttu-id="98221-152">下列的參數名稱使用大小寫不正確：</span><span class="sxs-lookup"><span data-stu-id="98221-152">The following parameter names use incorrect capitalization:</span></span>

- `errorAction`

- `erroraction`

#### <a name="parameters-that-take-a-list-of-options"></a><span data-ttu-id="98221-153">參數選項的清單</span><span class="sxs-lookup"><span data-stu-id="98221-153">Parameters That Take a List of Options</span></span>

<span data-ttu-id="98221-154">有兩種方式可建立其值可以從一組選項中選取的參數。</span><span class="sxs-lookup"><span data-stu-id="98221-154">There are two ways to create a parameter whose value can be selected from a set of options.</span></span>

- <span data-ttu-id="98221-155">定義列舉類型 （或使用現有的列舉類型） 指定有效的值。</span><span class="sxs-lookup"><span data-stu-id="98221-155">Define an enumeration type (or use an existing enumeration type) that specifies the valid values.</span></span> <span data-ttu-id="98221-156">然後，使用的列舉型別來建立該類型的參數。</span><span class="sxs-lookup"><span data-stu-id="98221-156">Then, use the enumeration type to create a parameter of that type.</span></span>

- <span data-ttu-id="98221-157">新增**ValidateSet**屬性參數宣告。</span><span class="sxs-lookup"><span data-stu-id="98221-157">Add the **ValidateSet** attribute to the parameter declaration.</span></span> <span data-ttu-id="98221-158">如需有關這個屬性的詳細資訊，請參閱 < [ValidateSet 屬性宣告](./validateset-attribute-declaration.md)。</span><span class="sxs-lookup"><span data-stu-id="98221-158">For more information about this attribute, see [ValidateSet Attribute Declaration](./validateset-attribute-declaration.md).</span></span>

#### <a name="use-standard-types-for-parameters"></a><span data-ttu-id="98221-159">使用標準的類型參數</span><span class="sxs-lookup"><span data-stu-id="98221-159">Use Standard Types for Parameters</span></span>

<span data-ttu-id="98221-160">若要確保與其他 cmdlet 保持一致，使用標準類型參數，其中以往可能。</span><span class="sxs-lookup"><span data-stu-id="98221-160">To ensure consistency with other cmdlets, use standard types for parameters where ever possible.</span></span> <span data-ttu-id="98221-161">如需應該使用不同的參數類型的詳細資訊，請參閱[標準的 Cmdlet 參數名稱和型別](./standard-cmdlet-parameter-names-and-types.md)。</span><span class="sxs-lookup"><span data-stu-id="98221-161">For more information about the types that should be used for different parameter, see [Standard Cmdlet Parameter Names and Types](./standard-cmdlet-parameter-names-and-types.md).</span></span> <span data-ttu-id="98221-162">本主題提供數個描述的名稱和群組的標準參數，例如 「 活動參數 」 的.NET Framework 類型的主題連結。</span><span class="sxs-lookup"><span data-stu-id="98221-162">This topic provides links to several topics that describe the names and .NET Framework types for groups of standard parameters, such as the "activity parameters".</span></span>

#### <a name="use-strongly-typed-net-framework-types"></a><span data-ttu-id="98221-163">使用強型別.NET Framework 型別</span><span class="sxs-lookup"><span data-stu-id="98221-163">Use Strongly-Typed .NET Framework Types</span></span>

<span data-ttu-id="98221-164">參數應定義為.NET Framework 型別，以提供更好的參數驗證。</span><span class="sxs-lookup"><span data-stu-id="98221-164">Parameters should be defined as .NET Framework types to provide better parameter validation.</span></span> <span data-ttu-id="98221-165">例如，從一組值限制為一個值的參數應該定義為列舉型別。</span><span class="sxs-lookup"><span data-stu-id="98221-165">For example, parameters that are restricted to one value from a set of values should be defined as an enumeration type.</span></span> <span data-ttu-id="98221-166">若要支援的統一資源識別元 (URI) 值，定義為參數[System.Uri](/dotnet/api/System.Uri)型別。</span><span class="sxs-lookup"><span data-stu-id="98221-166">To support a Uniform Resource Identifier (URI) value, define the parameter as a [System.Uri](/dotnet/api/System.Uri) type.</span></span> <span data-ttu-id="98221-167">避免以外的所有自由格式文字屬性的基本字串參數。</span><span class="sxs-lookup"><span data-stu-id="98221-167">Avoid basic string parameters for all but free-form text properties.</span></span>

#### <a name="use-consistent-parameter-types"></a><span data-ttu-id="98221-168">使用一致的參數類型</span><span class="sxs-lookup"><span data-stu-id="98221-168">Use Consistent Parameter Types</span></span>

<span data-ttu-id="98221-169">當多個指令程式使用相同的參數時，一律使用相同的參數類型。</span><span class="sxs-lookup"><span data-stu-id="98221-169">When the same parameter is used by multiple cmdlets, always use the same parameter type.</span></span>  <span data-ttu-id="98221-170">例如，如果`Process`參數是[System.Int16](/dotnet/api/System.Int16)輸入一個 cmdlet，則請勿`Process`另一個 cmdlet 的參數[System.Uint16](/dotnet/api/System.UInt16)型別。</span><span class="sxs-lookup"><span data-stu-id="98221-170">For example, if the `Process` parameter is an [System.Int16](/dotnet/api/System.Int16) type for one cmdlet, do not make the `Process` parameter for another cmdlet a [System.Uint16](/dotnet/api/System.UInt16) type.</span></span>

#### <a name="parameters-that-take-true-and-false"></a><span data-ttu-id="98221-171">參數為 True 和 False</span><span class="sxs-lookup"><span data-stu-id="98221-171">Parameters That Take True and False</span></span>

<span data-ttu-id="98221-172">如果您的參數只接受`true`並`false`，此參數定義為類型[System.Management.Automation.SwitchParameter](/dotnet/api/System.Management.Automation.SwitchParameter)。</span><span class="sxs-lookup"><span data-stu-id="98221-172">If your parameter takes only `true` and `false`, define the parameter as type [System.Management.Automation.SwitchParameter](/dotnet/api/System.Management.Automation.SwitchParameter).</span></span> <span data-ttu-id="98221-173">切換參數會被視為`true`當命令中指定。</span><span class="sxs-lookup"><span data-stu-id="98221-173">A switch parameter is treated as `true` when it is specified in a command.</span></span> <span data-ttu-id="98221-174">如果參數未包含在命令中，Windows PowerShell，將會視為是參數的值`false`。</span><span class="sxs-lookup"><span data-stu-id="98221-174">If the parameter is not included in a command, Windows PowerShell considers the value of the parameter to be `false`.</span></span> <span data-ttu-id="98221-175">未定義布林值參數。</span><span class="sxs-lookup"><span data-stu-id="98221-175">Do not define Boolean parameters.</span></span>

<span data-ttu-id="98221-176">如果您的參數需要 3 個值之間的區別： $true、 $false 和 「 未指定"，然後將參數定義型別可為 Null\<bool >。</span><span class="sxs-lookup"><span data-stu-id="98221-176">If your parameter needs to differentiate between 3 values: $true, $false and "unspecified", then define a parameter of type Nullable\<bool>.</span></span>  <span data-ttu-id="98221-177">第 3 需要，「 未指定"的值通常發生於此指令程式可以修改物件的布林值屬性。</span><span class="sxs-lookup"><span data-stu-id="98221-177">The need for a 3rd, "unspecified" value typically occurs when the cmdlet can modify a Boolean property of an object.</span></span> <span data-ttu-id="98221-178">在此情況下 「 未指定"表示不會變更屬性的目前值。</span><span class="sxs-lookup"><span data-stu-id="98221-178">In this case "unspecified" means to not change the current value of the property.</span></span>

#### <a name="support-arrays-for-parameters"></a><span data-ttu-id="98221-179">支援的參數陣列</span><span class="sxs-lookup"><span data-stu-id="98221-179">Support Arrays for Parameters</span></span>

<span data-ttu-id="98221-180">通常，使用者必須執行相同的作業，針對多個引數。</span><span class="sxs-lookup"><span data-stu-id="98221-180">Frequently, users must perform the same operation against multiple arguments.</span></span> <span data-ttu-id="98221-181">針對這些使用者，cmdlet 應接受陣列做為輸入，讓使用者可以將引數傳遞至 Windows PowerShell 變數作為參數的參數。</span><span class="sxs-lookup"><span data-stu-id="98221-181">For these users, a cmdlet should accept an array as parameter input so that a user can pass the arguments into the parameter as a Windows PowerShell variable.</span></span> <span data-ttu-id="98221-182">例如， [Get-process](/powershell/module/Microsoft.PowerShell.Management/Get-Process) cmdlet 用於識別要擷取的處理序名稱的字串陣列。</span><span class="sxs-lookup"><span data-stu-id="98221-182">For example, the [Get-Process](/powershell/module/Microsoft.PowerShell.Management/Get-Process) cmdlet uses an array for the strings that identify the names of the processes to retrieve.</span></span>

#### <a name="support-the-passthru-parameter"></a><span data-ttu-id="98221-183">支援的 PassThru 參數</span><span class="sxs-lookup"><span data-stu-id="98221-183">Support the PassThru Parameter</span></span>

<span data-ttu-id="98221-184">根據預設，許多 cmdlet，修改系統，例如[Stop-process](/powershell/module/Microsoft.PowerShell.Management/Stop-Process)指令程式，作為 「 接收 」 的物件，並不會傳回結果。</span><span class="sxs-lookup"><span data-stu-id="98221-184">By default, many cmdlets that modify the system, such as the [Stop-Process](/powershell/module/Microsoft.PowerShell.Management/Stop-Process) cmdlet, act as "sinks" for objects and do not return a result.</span></span> <span data-ttu-id="98221-185">這些 cmdlet 應該實作`PassThru`參數來強制 cmdlet 傳回的物件。</span><span class="sxs-lookup"><span data-stu-id="98221-185">These cmdlet should implement the `PassThru` parameter to force the cmdlet to return an object.</span></span> <span data-ttu-id="98221-186">當`PassThru`指定參數，cmdlet 會傳回物件使用呼叫[System.Management.Automation.Cmdlet.WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject)方法。</span><span class="sxs-lookup"><span data-stu-id="98221-186">When the `PassThru` parameter is specified, the cmdlet returns an object by using a call to the [System.Management.Automation.Cmdlet.WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) method.</span></span> <span data-ttu-id="98221-187">例如，下列命令停止 Calc 處理程序，並將結果的程序傳遞到管線。</span><span class="sxs-lookup"><span data-stu-id="98221-187">For example, the following command stops the Calc process and passes the resultant process to the pipeline.</span></span>

```powershell
Stop-Process calc -passthru
```

<span data-ttu-id="98221-188">在大部分情況下，新增、 集和新的 cmdlet 應該支援`PassThru`參數。</span><span class="sxs-lookup"><span data-stu-id="98221-188">In most cases, Add, Set, and New cmdlets should support a `PassThru` parameter.</span></span>

#### <a name="support-parameter-sets"></a><span data-ttu-id="98221-189">支援的參數集</span><span class="sxs-lookup"><span data-stu-id="98221-189">Support Parameter Sets</span></span>

<span data-ttu-id="98221-190">Cmdlet 被用來完成單一用途。</span><span class="sxs-lookup"><span data-stu-id="98221-190">A cmdlet is intended to accomplish a single purpose.</span></span> <span data-ttu-id="98221-191">不過，還有常見問題描述作業或作業目標的多個方法。</span><span class="sxs-lookup"><span data-stu-id="98221-191">However, there is frequently more than one way to describe the operation or the operation target.</span></span> <span data-ttu-id="98221-192">比方說，其名稱、 其識別項，或處理程序物件，可能會識別處理程序。</span><span class="sxs-lookup"><span data-stu-id="98221-192">For example, a process might be identified by its name, by its identifier, or by a process object.</span></span> <span data-ttu-id="98221-193">此 cmdlet 應支援其目標合理的表示法。</span><span class="sxs-lookup"><span data-stu-id="98221-193">The cmdlet should support all the reasonable representations of its targets.</span></span> <span data-ttu-id="98221-194">一般來說，此 cmdlet 會滿足此需求，藉由指定的參數 （稱為參數集） 一起運作的設定。</span><span class="sxs-lookup"><span data-stu-id="98221-194">Normally, the cmdlet satisfies this requirement by specifying sets of parameters (referred to as parameter sets) that operate together.</span></span> <span data-ttu-id="98221-195">單一參數可以屬於任何數目的參數集合。</span><span class="sxs-lookup"><span data-stu-id="98221-195">A single parameter can belong to any number of parameter sets.</span></span> <span data-ttu-id="98221-196">如需參數集的詳細資訊，請參閱[指令程式參數設定](./cmdlet-parameter-sets.md)。</span><span class="sxs-lookup"><span data-stu-id="98221-196">For more information about parameter sets, see [Cmdlet Parameter Sets](./cmdlet-parameter-sets.md).</span></span>

<span data-ttu-id="98221-197">當您指定的參數集時，請 ValueFromPipeline 來集中設定只有一個參數。</span><span class="sxs-lookup"><span data-stu-id="98221-197">When you specify parameter sets, set only one parameter in the set to ValueFromPipeline.</span></span> <span data-ttu-id="98221-198">如需如何宣告**參數**屬性，請參閱[ParameterAttribute 宣告](./parameter-attribute-declaration.md)。</span><span class="sxs-lookup"><span data-stu-id="98221-198">For more information about how to declare the **Parameter** attribute, see [ParameterAttribute Declaration](./parameter-attribute-declaration.md).</span></span>

<span data-ttu-id="98221-199">當使用參數集時，所定義的預設參數集**Cmdlet**屬性。</span><span class="sxs-lookup"><span data-stu-id="98221-199">When parameter sets are used, the default parameter set is defined by the **Cmdlet** attribute.</span></span> <span data-ttu-id="98221-200">預設參數集應該包含最可能使用互動式的 Windows PowerShell 工作階段中的參數。</span><span class="sxs-lookup"><span data-stu-id="98221-200">The default parameter set should include the parameters most likely to be used in an interactive Windows PowerShell session.</span></span> <span data-ttu-id="98221-201">如需如何宣告**Cmdlet**屬性，請參閱[CmdletAttribute 宣告](./cmdlet-attribute-declaration.md)。</span><span class="sxs-lookup"><span data-stu-id="98221-201">For more information about how to declare the **Cmdlet** attribute, see [CmdletAttribute Declaration](./cmdlet-attribute-declaration.md).</span></span>

### <a name="provide-feedback-to-the-user-sd04"></a><span data-ttu-id="98221-202">提供意見給使用者 (SD04)</span><span class="sxs-lookup"><span data-stu-id="98221-202">Provide Feedback to the User (SD04)</span></span>

<span data-ttu-id="98221-203">使用本節中的指導方針，提供回饋給使用者。</span><span class="sxs-lookup"><span data-stu-id="98221-203">Use the guidelines in this section to provide feedback to the user.</span></span> <span data-ttu-id="98221-204">此意見反應可讓使用者知道什麼系統中發生的並做出更好的系統管理決策。</span><span class="sxs-lookup"><span data-stu-id="98221-204">This feedback allows the user to be aware of what is occurring in the system and to make better administrative decisions.</span></span>

<span data-ttu-id="98221-205">Windows PowerShell 執行階段可讓使用者指定如何處理每次呼叫的輸出`Write`藉由設定 喜好設定變數的方法。</span><span class="sxs-lookup"><span data-stu-id="98221-205">The Windows PowerShell runtime allows a user to specify how to handle output from each call to the `Write` method by setting a preference variable.</span></span> <span data-ttu-id="98221-206">使用者可以設定數個喜好設定變數，包括判斷系統是否應該顯示資訊，以及判斷系統是否應該查詢使用者再採取進一步的動作變數的變數。</span><span class="sxs-lookup"><span data-stu-id="98221-206">The user can set several preference variables, including a variable that determines whether the system should display information and a variable that determines whether the system should query the user before taking further action.</span></span>

#### <a name="support-the-writewarning-writeverbose-and-writedebug-methods"></a><span data-ttu-id="98221-207">支援 WriteWarning、 WriteVerbose 和 WriteDebug 方法</span><span class="sxs-lookup"><span data-stu-id="98221-207">Support the WriteWarning, WriteVerbose, and WriteDebug Methods</span></span>

<span data-ttu-id="98221-208">指令程式應該呼叫[System.Management.Automation.Cmdlet.WriteWarning](/dotnet/api/System.Management.Automation.Cmdlet.WriteWarning)方法時執行的作業可能會有非預期的結果，此 cmdlet。</span><span class="sxs-lookup"><span data-stu-id="98221-208">A cmdlet should call the [System.Management.Automation.Cmdlet.WriteWarning](/dotnet/api/System.Management.Automation.Cmdlet.WriteWarning) method when the cmdlet is about to perform an operation that might have an unintended result.</span></span> <span data-ttu-id="98221-209">比方說，指令程式應該呼叫這個方法，此 cmdlet 是否要覆寫唯讀檔案。</span><span class="sxs-lookup"><span data-stu-id="98221-209">For example, a cmdlet should call this method if the cmdlet is about to overwrite a read-only file.</span></span>

<span data-ttu-id="98221-210">指令程式應該呼叫[System.Management.Automation.Cmdlet.WriteVerbose](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose)方法，當使用者要求有關此指令程式會執行的工作詳細資料。</span><span class="sxs-lookup"><span data-stu-id="98221-210">A cmdlet should call the [System.Management.Automation.Cmdlet.WriteVerbose](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) method when the user requires some detail about what the cmdlet is doing.</span></span> <span data-ttu-id="98221-211">比方說，指令程式應該呼叫這項資訊，如果 cmdlet 的作者都有可能會要求有關此指令程式會執行的工作的詳細資訊的情況。</span><span class="sxs-lookup"><span data-stu-id="98221-211">For example, a cmdlet should call this information if the cmdlet author feels that there are scenarios that might require more information about what the cmdlet is doing.</span></span>

<span data-ttu-id="98221-212">此指令程式應該呼叫[System.Management.Automation.Cmdlet.WriteDebug](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug)當開發人員或產品的支援工程師必須了解什麼有損毀 cmdlet 作業的方法。</span><span class="sxs-lookup"><span data-stu-id="98221-212">The cmdlet should call the [System.Management.Automation.Cmdlet.WriteDebug](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) method when a developer or product support engineer must understand what has corrupted the cmdlet operation.</span></span> <span data-ttu-id="98221-213">它不需要此指令程式來呼叫[System.Management.Automation.Cmdlet.WriteDebug](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug)方法中呼叫的程式碼[System.Management.Automation.Cmdlet.WriteVerbose](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose)方法因為`Debug`參數提供兩個資訊集。</span><span class="sxs-lookup"><span data-stu-id="98221-213">It is not necessary for the cmdlet to call the [System.Management.Automation.Cmdlet.WriteDebug](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) method in the same code that calls the [System.Management.Automation.Cmdlet.WriteVerbose](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) method because the `Debug` parameter presents both sets of information.</span></span>

#### <a name="support-writeprogress-for-operations-that-take-a-long-time"></a><span data-ttu-id="98221-214">支援 WriteProgress 很耗時的作業</span><span class="sxs-lookup"><span data-stu-id="98221-214">Support WriteProgress for Operations that take a Long Time</span></span>

<span data-ttu-id="98221-215">Cmdlet 作業很長的時間才能完成，而且不能在背景執行的採用應該支援進度報告透過定期呼叫[System.Management.Automation.Cmdlet.WriteProgress](/dotnet/api/System.Management.Automation.Cmdlet.WriteProgress)方法。</span><span class="sxs-lookup"><span data-stu-id="98221-215">Cmdlet operations that take a long time to complete and that cannot run in the background should support progress reporting through periodic calls to the [System.Management.Automation.Cmdlet.WriteProgress](/dotnet/api/System.Management.Automation.Cmdlet.WriteProgress) method.</span></span>

#### <a name="use-the-host-interfaces"></a><span data-ttu-id="98221-216">使用主應用程式介面</span><span class="sxs-lookup"><span data-stu-id="98221-216">Use the Host Interfaces</span></span>

<span data-ttu-id="98221-217">有時候，cmdlet 必須直接與使用者通訊而不是使用各種書寫或應該支援的方法[System.Management.Automation.Cmdlet](/dotnet/api/System.Management.Automation.Cmdlet)類別。</span><span class="sxs-lookup"><span data-stu-id="98221-217">Occasionally, a cmdlet must communicate directly with the user instead of by using the various Write or Should methods supported by the [System.Management.Automation.Cmdlet](/dotnet/api/System.Management.Automation.Cmdlet) class.</span></span> <span data-ttu-id="98221-218">在此情況下，此 cmdlet 應該衍生自[System.Management.Automation.PSCmdlet](/dotnet/api/System.Management.Automation.PSCmdlet)類別，並且使用[System.Management.Automation.PSCmdlet.Host\*](/dotnet/api/System.Management.Automation.PSCmdlet.Host)屬性。</span><span class="sxs-lookup"><span data-stu-id="98221-218">In this case, the cmdlet should derive from the [System.Management.Automation.PSCmdlet](/dotnet/api/System.Management.Automation.PSCmdlet) class and use the [System.Management.Automation.PSCmdlet.Host\*](/dotnet/api/System.Management.Automation.PSCmdlet.Host) property.</span></span> <span data-ttu-id="98221-219">此屬性支援不同層級的通訊類型，包括 PromptForChoice、 提示和 WriteLine/ReadLine 的型別。</span><span class="sxs-lookup"><span data-stu-id="98221-219">This property supports different levels of communication type, including the PromptForChoice, Prompt, and WriteLine/ReadLine types.</span></span> <span data-ttu-id="98221-220">在最特定的層級，它也提供方法來讀取和寫入個別的索引鍵，並處理緩衝區。</span><span class="sxs-lookup"><span data-stu-id="98221-220">At the most specific level, it also provides ways to read and write individual keys and to deal with buffers.</span></span>

<span data-ttu-id="98221-221">除非 cmdlet 專為產生的圖形化使用者介面 (GUI)，它應該不使用略過主機[System.Management.Automation.PSCmdlet.Host\*](/dotnet/api/System.Management.Automation.PSCmdlet.Host)屬性。</span><span class="sxs-lookup"><span data-stu-id="98221-221">Unless a cmdlet is specifically designed to generate a graphical user interface (GUI), it should not bypass the host by using the [System.Management.Automation.PSCmdlet.Host\*](/dotnet/api/System.Management.Automation.PSCmdlet.Host) property.</span></span> <span data-ttu-id="98221-222">舉例來說，設計來產生 GUI 指令程式可[Out-gridview](/powershell/module/Microsoft.PowerShell.Utility/Out-GridView) cmdlet。</span><span class="sxs-lookup"><span data-stu-id="98221-222">An example of a cmdlet that is designed to generate a GUI is the [Out-GridView](/powershell/module/Microsoft.PowerShell.Utility/Out-GridView) cmdlet.</span></span>

> [!NOTE]
> <span data-ttu-id="98221-223">不應該使用 Cmdlet [System.Console](/dotnet/api/System.Console) API。</span><span class="sxs-lookup"><span data-stu-id="98221-223">Cmdlets should not use the [System.Console](/dotnet/api/System.Console) API.</span></span>

### <a name="create-a-cmdlet-help-file-sd05"></a><span data-ttu-id="98221-224">建立 Cmdlet 說明檔 (SD05)</span><span class="sxs-lookup"><span data-stu-id="98221-224">Create a Cmdlet Help File (SD05)</span></span>

<span data-ttu-id="98221-225">每個 cmdlet，為組件建立 Help.xml 檔案，其中包含有關此指令程式的資訊。</span><span class="sxs-lookup"><span data-stu-id="98221-225">For each cmdlet assembly, create a Help.xml file that contains information about the cmdlet.</span></span> <span data-ttu-id="98221-226">這項資訊包含 cmdlet，cmdlet 的參數的描述，範例 cmdlet 的使用，以及更多的描述。</span><span class="sxs-lookup"><span data-stu-id="98221-226">This information includes a description of the cmdlet, descriptions of the cmdlet's parameters, examples of the cmdlet's use, and more.</span></span>

## <a name="code-guidelines"></a><span data-ttu-id="98221-227">程式碼的指導方針</span><span class="sxs-lookup"><span data-stu-id="98221-227">Code Guidelines</span></span>

<span data-ttu-id="98221-228">撰寫程式碼以確保一致的使用者經驗之間使用您的 cmdlet 和其他 cmdlet 的 cmdlet 時，應該遵循下列指導方針。</span><span class="sxs-lookup"><span data-stu-id="98221-228">The following guidelines should be followed when coding cmdlets to ensure a consistent user experience between using your cmdlets and other cmdlets.</span></span> <span data-ttu-id="98221-229">當您找到適用於您情況的程式碼指導方針時，請務必查看類似的指導方針的設計方針。</span><span class="sxs-lookup"><span data-stu-id="98221-229">When you find a Code guideline that applies to your situation, be sure to look at the Design guidelines for similar guidelines.</span></span>

### <a name="coding-parameters-sc01"></a><span data-ttu-id="98221-230">程式碼參數 (SC01)</span><span class="sxs-lookup"><span data-stu-id="98221-230">Coding Parameters (SC01)</span></span>

<span data-ttu-id="98221-231">藉由宣告以裝飾在 cmdlet 類別的公用屬性來定義參數**參數**屬性。</span><span class="sxs-lookup"><span data-stu-id="98221-231">Define a parameter by declaring a public property of the cmdlet class that is decorated with the **Parameter** attribute.</span></span> <span data-ttu-id="98221-232">參數可能沒有 cmdlet 衍生的.NET Framework 類別的靜態成員。</span><span class="sxs-lookup"><span data-stu-id="98221-232">Parameters do not have to be static members of the derived .NET Framework class for the cmdlet.</span></span> <span data-ttu-id="98221-233">如需如何宣告**參數**屬性，請參閱[參數的屬性宣告](./parameter-attribute-declaration.md)。</span><span class="sxs-lookup"><span data-stu-id="98221-233">For more information about how to declare the **Parameter** attribute, see [Parameter Attribute Declaration](./parameter-attribute-declaration.md).</span></span>

#### <a name="support-windows-powershell-paths"></a><span data-ttu-id="98221-234">支援 Windows PowerShell 路徑</span><span class="sxs-lookup"><span data-stu-id="98221-234">Support Windows PowerShell Paths</span></span>

<span data-ttu-id="98221-235">Windows PowerShell 路徑會是正規化命名空間的存取權的機制。</span><span class="sxs-lookup"><span data-stu-id="98221-235">The Windows PowerShell path is the mechanism for normalizing access to namespaces.</span></span> <span data-ttu-id="98221-236">當您指派的 Windows PowerShell 路徑中 cmdlet 的參數時，使用者可以定義自訂的 「 磁碟機 」，可作為特定路徑的捷徑。</span><span class="sxs-lookup"><span data-stu-id="98221-236">When you assign a Windows PowerShell path to a parameter in the cmdlet, the user can define a custom "drive" that acts as a shortcut to a specific path.</span></span> <span data-ttu-id="98221-237">當使用者指定這類磁碟機時，預存的資料，例如在登錄中的資料可以用於以一致的方式。</span><span class="sxs-lookup"><span data-stu-id="98221-237">When a user designates such a drive, stored data, such as data in the Registry, can be used in a consistent way.</span></span>

<span data-ttu-id="98221-238">如果您的指令程式可讓使用者指定的檔案或資料來源，它應該定義類型的參數[System.String](/dotnet/api/System.String)。</span><span class="sxs-lookup"><span data-stu-id="98221-238">If your cmdlet allows the user to specify a file or a data source, it should define a parameter of type [System.String](/dotnet/api/System.String).</span></span> <span data-ttu-id="98221-239">如果支援多個磁碟機，則類型應該是陣列。</span><span class="sxs-lookup"><span data-stu-id="98221-239">If more than one drive is supported, the type should be an array.</span></span> <span data-ttu-id="98221-240">參數的名稱應該是`Path`，使用的別名`PSPath`。</span><span class="sxs-lookup"><span data-stu-id="98221-240">The name of the parameter should be `Path`, with an alias of `PSPath`.</span></span> <span data-ttu-id="98221-241">此外，`Path`參數應該支援萬用字元。</span><span class="sxs-lookup"><span data-stu-id="98221-241">Additionally, the `Path` parameter should support wildcard characters.</span></span> <span data-ttu-id="98221-242">如果支援萬用字元並不需要，定義`LiteralPath`參數。</span><span class="sxs-lookup"><span data-stu-id="98221-242">If support for wildcard characters is not required, define a `LiteralPath` parameter.</span></span>

<span data-ttu-id="98221-243">如果指令程式會讀取或寫入的資料必須是檔案、 指令程式應該接受 Windows PowerShell 路徑輸入，而且應該使用此 cmdlet [System.Management.Automation.Sessionstate.Path](/dotnet/api/System.Management.Automation.SessionState.Path)屬性，以轉譯 Windows為路徑的檔案系統可辨識的 PowerShell 路徑。</span><span class="sxs-lookup"><span data-stu-id="98221-243">If the data that the cmdlet reads or writes has to be a file, the cmdlet should accept Windows PowerShell path input, and the cmdlet should use the [System.Management.Automation.Sessionstate.Path](/dotnet/api/System.Management.Automation.SessionState.Path) property to translate the Windows PowerShell paths into paths that the file system recognizes.</span></span> <span data-ttu-id="98221-244">特定的機制包括下列方法：</span><span class="sxs-lookup"><span data-stu-id="98221-244">The specific mechanisms include the following methods:</span></span>

- [<span data-ttu-id="98221-245">System.Management.Automation.PSCmdlet.GetResolvedProviderPathFromPSPath</span><span class="sxs-lookup"><span data-stu-id="98221-245">System.Management.Automation.PSCmdlet.GetResolvedProviderPathFromPSPath</span></span>](/dotnet/api/System.Management.Automation.PSCmdlet.GetResolvedProviderPathFromPSPath)

- [<span data-ttu-id="98221-246">System.Management.Automation.PSCmdlet.GetUnresolvedProviderPathFromPSPath</span><span class="sxs-lookup"><span data-stu-id="98221-246">System.Management.Automation.PSCmdlet.GetUnresolvedProviderPathFromPSPath</span></span>](/dotnet/api/System.Management.Automation.PSCmdlet.GetUnresolvedProviderPathFromPSPath)

- [<span data-ttu-id="98221-247">System.Management.Automation.PathIntrinsics.GetResolvedProviderPathFromPSPath</span><span class="sxs-lookup"><span data-stu-id="98221-247">System.Management.Automation.PathIntrinsics.GetResolvedProviderPathFromPSPath</span></span>](/dotnet/api/System.Management.Automation.PathIntrinsics.GetResolvedProviderPathFromPSPath)

- [<span data-ttu-id="98221-248">System.Management.Automation.PathIntrinsics.GetUnresolvedProviderPathFromPSPath</span><span class="sxs-lookup"><span data-stu-id="98221-248">System.Management.Automation.PathIntrinsics.GetUnresolvedProviderPathFromPSPath</span></span>](/dotnet/api/System.Management.Automation.PathIntrinsics.GetUnresolvedProviderPathFromPSPath)

<span data-ttu-id="98221-249">指令程式會讀取或寫入的資料如果只是一組字串，而不是檔案時，此指令程式應該使用提供者的內容資訊 (`Content`成員) 來讀取和寫入。</span><span class="sxs-lookup"><span data-stu-id="98221-249">If the data that the cmdlet reads or writes is only a set of strings instead of a file, the cmdlet should use the provider content information (`Content` member) to read and write.</span></span> <span data-ttu-id="98221-250">這項資訊取自[System.Management.Automation.Provider.CmdletProvider.InvokeProvider](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.InvokeProvider)屬性。</span><span class="sxs-lookup"><span data-stu-id="98221-250">This information is obtained from the [System.Management.Automation.Provider.CmdletProvider.InvokeProvider](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.InvokeProvider) property.</span></span> <span data-ttu-id="98221-251">這些機制讓參與讀取和寫入資料的其他資料存放區。</span><span class="sxs-lookup"><span data-stu-id="98221-251">These mechanisms allow other data stores to participate in the reading and writing of data.</span></span>

#### <a name="support-wildcard-characters"></a><span data-ttu-id="98221-252">支援萬用字元</span><span class="sxs-lookup"><span data-stu-id="98221-252">Support Wildcard Characters</span></span>

<span data-ttu-id="98221-253">指令程式應該盡可能支援萬用字元。</span><span class="sxs-lookup"><span data-stu-id="98221-253">A cmdlet should support wildcard characters if possible.</span></span> <span data-ttu-id="98221-254">（尤其是當參數接受字串，以識別一組物件中的一個物件），就會在 cmdlet 中的許多地方發生萬用字元的支援。</span><span class="sxs-lookup"><span data-stu-id="98221-254">Support for wildcard characters occurs in many places in a cmdlet (especially when a parameter takes a string to identify one object from a set of objects).</span></span> <span data-ttu-id="98221-255">例如，範例**停止程序**cmdlet，從[StopProc 教學課程](./stopproc-tutorial.md)定義`Name`參數，以處理表示處理程序名稱的字串。</span><span class="sxs-lookup"><span data-stu-id="98221-255">For example, the sample **Stop-Proc** cmdlet from the [StopProc Tutorial](./stopproc-tutorial.md) defines a `Name` parameter to handle strings that represent process names.</span></span> <span data-ttu-id="98221-256">這個參數支援萬用字元，因此使用者可以輕鬆地指定處理程序停止。</span><span class="sxs-lookup"><span data-stu-id="98221-256">This parameter supports wildcard characters so that the user can easily specify the processes to stop.</span></span>

<span data-ttu-id="98221-257">當支援萬用字元的字元可用，cmdlet 作業通常會產生陣列。</span><span class="sxs-lookup"><span data-stu-id="98221-257">When support for wildcard characters is available, a cmdlet operation usually produces an array.</span></span> <span data-ttu-id="98221-258">有時候，並不合理支援陣列，因為使用者可能會一次使用單一項目。</span><span class="sxs-lookup"><span data-stu-id="98221-258">Occasionally, it does not make sense to support an array because the user might use only a single item at a time.</span></span> <span data-ttu-id="98221-259">例如， [Set-location](/powershell/module/Microsoft.PowerShell.Management/Set-Location) cmdlet 就不需要支援陣列，因為使用者設定的就單一位置。</span><span class="sxs-lookup"><span data-stu-id="98221-259">For example, the [Set-Location](/powershell/module/Microsoft.PowerShell.Management/Set-Location) cmdlet does not need to support an array because the user is setting only a single location.</span></span> <span data-ttu-id="98221-260">在此情況下，cmdlet 仍然支援萬用字元，但它會強制解析至單一位置。</span><span class="sxs-lookup"><span data-stu-id="98221-260">In this instance, the cmdlet still supports wildcard characters, but it forces resolution to a single location.</span></span>

<span data-ttu-id="98221-261">如需萬用字元字元模式的詳細資訊，請參閱[Cmdlet 參數支援萬用字元](./supporting-wildcard-characters-in-cmdlet-parameters.md)。</span><span class="sxs-lookup"><span data-stu-id="98221-261">For more information about wildcard-character patterns, see [Supporting Wildcard Characters in Cmdlet Parameters](./supporting-wildcard-characters-in-cmdlet-parameters.md).</span></span>

#### <a name="defining-objects"></a><span data-ttu-id="98221-262">定義物件</span><span class="sxs-lookup"><span data-stu-id="98221-262">Defining Objects</span></span>

<span data-ttu-id="98221-263">本章節包含的 cmdlet 以及擴充現有物件的物件定義的指導方針。</span><span class="sxs-lookup"><span data-stu-id="98221-263">This section contains guidelines for defining objects for cmdlets and for extending existing objects.</span></span>

##### <a name="define-standard-members"></a><span data-ttu-id="98221-264">定義標準的成員</span><span class="sxs-lookup"><span data-stu-id="98221-264">Define Standard Members</span></span>

<span data-ttu-id="98221-265">定義標準的成員，來擴充自訂的 Types.ps1xml 檔案 （使用 Windows PowerShell Types.ps1xml 檔案做為範本） 中的物件類型。</span><span class="sxs-lookup"><span data-stu-id="98221-265">Define standard members to extend an object type in a custom Types.ps1xml file (use the Windows PowerShell Types.ps1xml file as a template).</span></span> <span data-ttu-id="98221-266">標準的成員會定義具有名稱 PSStandardMembers 的節點。</span><span class="sxs-lookup"><span data-stu-id="98221-266">Standard members are defined by a node with the name PSStandardMembers.</span></span> <span data-ttu-id="98221-267">其他指令程式和 Windows PowerShell 執行階段以一致的方式與您的物件，可讓這些定義。</span><span class="sxs-lookup"><span data-stu-id="98221-267">These definitions allow other cmdlets and the Windows PowerShell runtime to work with your object in a consistent way.</span></span>

##### <a name="define-objectmembers-to-be-used-as-parameters"></a><span data-ttu-id="98221-268">定義 ObjectMembers 來做為參數</span><span class="sxs-lookup"><span data-stu-id="98221-268">Define ObjectMembers to Be Used as Parameters</span></span>

<span data-ttu-id="98221-269">如果您要設計的 cmdlet 的物件，請確定，其成員會直接對應到就會使用此 cmdlet 的參數。</span><span class="sxs-lookup"><span data-stu-id="98221-269">If you are designing an object for a cmdlet, ensure that its members map directly to the parameters of the cmdlets that will use it.</span></span> <span data-ttu-id="98221-270">此對應可讓您輕鬆地傳送至管線，並從一個 cmdlet 傳遞到另一個物件。</span><span class="sxs-lookup"><span data-stu-id="98221-270">This mapping allows the object to be easily sent to the pipeline and to be passed from one cmdlet to another.</span></span>

<span data-ttu-id="98221-271">預先存在的 cmdlet 所傳回的.NET Framework 物件經常缺少某些重要或方便存取的成員所需的指令碼開發人員或使用者。</span><span class="sxs-lookup"><span data-stu-id="98221-271">Preexisting .NET Framework objects that are returned by cmdlets are frequently missing some important or convenient members that are needed by the script developer or user.</span></span> <span data-ttu-id="98221-272">這些遺漏的成員可以是供顯示及建立正確的成員名稱，使物件可以正確地傳遞到管線的特別重要。</span><span class="sxs-lookup"><span data-stu-id="98221-272">These missing members can be particularly important for display and for creating the correct member names so that the object can be correctly passed to the pipeline.</span></span> <span data-ttu-id="98221-273">建立自訂的 Types.ps1xml 檔案，以便記錄這些必要的成員。</span><span class="sxs-lookup"><span data-stu-id="98221-273">Create a custom Types.ps1xml file to document these required members.</span></span> <span data-ttu-id="98221-274">當您建立此檔案時，我們建議下列命名慣例： *< Your_Product_Name >*。Types.ps1xml。</span><span class="sxs-lookup"><span data-stu-id="98221-274">When you create this file, we recommend the following naming convention: *<Your_Product_Name>*.Types.ps1xml.</span></span>

<span data-ttu-id="98221-275">例如，您可以在其中加入`Mode`指令碼屬性到[System.IO.FileInfo](/dotnet/api/System.IO.FileInfo)更清楚地顯示檔案屬性的型別。</span><span class="sxs-lookup"><span data-stu-id="98221-275">For example, you could add a `Mode` script property to the [System.IO.FileInfo](/dotnet/api/System.IO.FileInfo) type to display the attributes of a file more clearly.</span></span> <span data-ttu-id="98221-276">此外，您可以在其中加入`Count`別名屬性[System.Array](/dotnet/api/System.Array)允許一致使用該屬性名稱的型別 (而不是`Length`)。</span><span class="sxs-lookup"><span data-stu-id="98221-276">Additionally, you could add a `Count` alias property to the [System.Array](/dotnet/api/System.Array) type to allow the consistent use of that property name (instead of `Length`).</span></span>

##### <a name="implement-the-icomparable-interface"></a><span data-ttu-id="98221-277">實作 IComparable 介面</span><span class="sxs-lookup"><span data-stu-id="98221-277">Implement the IComparable Interface</span></span>

<span data-ttu-id="98221-278">實作[System.IComparable](/dotnet/api/System.IComparable)介面上所有的輸出物件。</span><span class="sxs-lookup"><span data-stu-id="98221-278">Implement a [System.IComparable](/dotnet/api/System.IComparable) interface on all output objects.</span></span> <span data-ttu-id="98221-279">這可讓以輕鬆輸送到各種不同的排序及分析 cmdlet 的輸出物件。</span><span class="sxs-lookup"><span data-stu-id="98221-279">This allows the output objects to be easily piped to various sorting and analysis cmdlets.</span></span>

##### <a name="update-display-information"></a><span data-ttu-id="98221-280">更新顯示的資訊</span><span class="sxs-lookup"><span data-stu-id="98221-280">Update Display Information</span></span>

<span data-ttu-id="98221-281">如果物件顯示未提供預期的結果，請建立自訂 *\<YourProductName >*。該物件的 Format.ps1xml 檔案。</span><span class="sxs-lookup"><span data-stu-id="98221-281">If the display for an object does not provide the expected results, create a custom *\<YourProductName>*.Format.ps1xml file for that object.</span></span>

### <a name="support-well-defined-pipeline-input-sc02"></a><span data-ttu-id="98221-282">支援妥善定義的管線輸入 (SC02)</span><span class="sxs-lookup"><span data-stu-id="98221-282">Support Well Defined Pipeline Input (SC02)</span></span>

#### <a name="implement-for-the-middle-of-a-pipeline"></a><span data-ttu-id="98221-283">管線的中介的實作</span><span class="sxs-lookup"><span data-stu-id="98221-283">Implement for the Middle of a Pipeline</span></span>

<span data-ttu-id="98221-284">實作假設，它會呼叫從管線的中介的 cmdlet （也就是其他指令程式會產生其輸入或取用它的輸出）。</span><span class="sxs-lookup"><span data-stu-id="98221-284">Implement a cmdlet assuming that it will be called from the middle of a pipeline (that is, other cmdlets will produce its input or consume its output).</span></span> <span data-ttu-id="98221-285">例如，您可能會假設`Get-Process`cmdlet，因為它會產生資料，只會當做在管線中第一個 cmdlet。</span><span class="sxs-lookup"><span data-stu-id="98221-285">For example, you might assume that the `Get-Process` cmdlet, because it generates data, is used only as the first cmdlet in a pipeline.</span></span> <span data-ttu-id="98221-286">不過，因為這個指令程式專為管線的中間，此 cmdlet 可讓先前的指令程式或資料管線，以指定要擷取的處理序中。</span><span class="sxs-lookup"><span data-stu-id="98221-286">However, because this cmdlet is designed for the middle of a pipeline, this cmdlet allows previous cmdlets or data in the pipeline to specify the processes to retrieve.</span></span>

#### <a name="support-input-from-the-pipeline"></a><span data-ttu-id="98221-287">支援來自管線的輸入</span><span class="sxs-lookup"><span data-stu-id="98221-287">Support Input from the Pipeline</span></span>

<span data-ttu-id="98221-288">在設定指令程式的每個參數，包含至少一個參數，支援從管線輸入。</span><span class="sxs-lookup"><span data-stu-id="98221-288">In each parameter set for a cmdlet, include at least one parameter that supports input from the pipeline.</span></span> <span data-ttu-id="98221-289">管線輸入的支援可讓使用者擷取資料或物件，將它們傳送至正確的參數集，並將結果直接傳遞給 cmdlet。</span><span class="sxs-lookup"><span data-stu-id="98221-289">Support for pipeline input allows the user to retrieve data or objects, to send them to the correct parameter set, and to pass the results directly to a cmdlet.</span></span>

<span data-ttu-id="98221-290">參數會接受來自管線的輸入，如果**參數**屬性包含`ValueFromPipeline`關鍵字，`ValueFromPipelineByPropertyName`關鍵字的屬性或在其宣告中的這兩個關鍵字。</span><span class="sxs-lookup"><span data-stu-id="98221-290">A parameter accepts input from the pipeline if the **Parameter** attribute includes the `ValueFromPipeline` keyword, the `ValueFromPipelineByPropertyName` keyword attribute, or both keywords in its  declaration.</span></span> <span data-ttu-id="98221-291">如果沒有任何參數在參數中設定的支援`ValueFromPipeline`或`ValueFromPipelineByPropertyName`關鍵字，此 cmdlet 無法有意義地在另一個 cmdlet 之後放置，因為它將會忽略任何管線輸入。</span><span class="sxs-lookup"><span data-stu-id="98221-291">If none of the parameters in a parameter set support the `ValueFromPipeline` or `ValueFromPipelineByPropertyName` keywords, the cmdlet cannot meaningfully be placed after another cmdlet because it will ignore any pipeline input.</span></span>

#### <a name="support-the-processrecord-method"></a><span data-ttu-id="98221-292">支援 ProcessRecord 方法</span><span class="sxs-lookup"><span data-stu-id="98221-292">Support the ProcessRecord Method</span></span>

<span data-ttu-id="98221-293">若要接受從管線中前面的 cmdlet 的所有記錄，必須實作您的 cmdlet [System.Management.Automation.Cmdlet.ProcessRecord](/dotnet/api/System.Management.Automation.Cmdlet.ProcessRecord)方法。</span><span class="sxs-lookup"><span data-stu-id="98221-293">To accept all the records from the preceding cmdlet in the pipeline, your cmdlet must implement the [System.Management.Automation.Cmdlet.ProcessRecord](/dotnet/api/System.Management.Automation.Cmdlet.ProcessRecord) method.</span></span> <span data-ttu-id="98221-294">Windows PowerShell 呼叫此方法許多次，一次傳送到您的 cmdlet 的每一筆記錄。</span><span class="sxs-lookup"><span data-stu-id="98221-294">Windows PowerShell calls this method multiple times, once for every record that is sent to your cmdlet.</span></span>

### <a name="write-single-records-to-the-pipeline-sc03"></a><span data-ttu-id="98221-295">將單一記錄寫入管線 (SC03)</span><span class="sxs-lookup"><span data-stu-id="98221-295">Write Single Records to the Pipeline (SC03)</span></span>

<span data-ttu-id="98221-296">當 cmdlet 會傳回物件時，則此 cmdlet 應該寫入物件立即產生。</span><span class="sxs-lookup"><span data-stu-id="98221-296">When a cmdlet returns objects, the cmdlet should write the objects immediately as they are generated.</span></span> <span data-ttu-id="98221-297">此 cmdlet 不應該保存它們以緩衝到結合的陣列。</span><span class="sxs-lookup"><span data-stu-id="98221-297">The cmdlet should not hold them in order to buffer them into a combined array.</span></span> <span data-ttu-id="98221-298">接收物件做為輸入的指令程式將可以處理、 顯示或處理和顯示的輸出物件，不會有延遲。</span><span class="sxs-lookup"><span data-stu-id="98221-298">The cmdlets that receive the objects as input will then be able to process, display, or process and display the output objects without delay.</span></span> <span data-ttu-id="98221-299">指令程式來產生輸出物件一次應該呼叫[System.Management.Automation.Cmdlet.WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject)方法。</span><span class="sxs-lookup"><span data-stu-id="98221-299">A cmdlet that generates output objects one at a time should call the [System.Management.Automation.Cmdlet.WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) method.</span></span> <span data-ttu-id="98221-300">指令程式來產生批次中的輸出物件 （例如，因為基礎的 API 傳回的輸出物件陣列） 應該呼叫[System.Management.Automation.Cmdlet.WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject)方法有二個參數設定若要`true`。</span><span class="sxs-lookup"><span data-stu-id="98221-300">A cmdlet that generates output objects in batches (for example, because an underlying API returns an array of output objects) should call the [System.Management.Automation.Cmdlet.WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) Method with its second parameter set to `true`.</span></span>

### <a name="make-cmdlets-case-insensitive-and-case-preserving-sc04"></a><span data-ttu-id="98221-301">讓 Cmdlet 不區分大小寫和保留大小寫 (SC04)</span><span class="sxs-lookup"><span data-stu-id="98221-301">Make Cmdlets Case-Insensitive and Case-Preserving (SC04)</span></span>

<span data-ttu-id="98221-302">根據預設，Windows PowerShell 本身是不區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="98221-302">By default, Windows PowerShell itself is case-insensitive.</span></span> <span data-ttu-id="98221-303">不過，因為它會處理許多預先存在的系統，Windows PowerShell 就會保留案例，簡化作業和相容性。</span><span class="sxs-lookup"><span data-stu-id="98221-303">However, because it deals with many preexisting systems, Windows PowerShell does preserve case for ease of operation and compatibility.</span></span> <span data-ttu-id="98221-304">換句話說，如果提供以大寫的字母字元，則 Windows PowerShell 會保留它以大寫的字母。</span><span class="sxs-lookup"><span data-stu-id="98221-304">In other words, if a character is supplied in uppercase letters, Windows PowerShell keeps it in uppercase letters.</span></span> <span data-ttu-id="98221-305">對於系統正常運作，指令程式必須遵循此慣例。</span><span class="sxs-lookup"><span data-stu-id="98221-305">For systems to work well, a cmdlet needs to follow this convention.</span></span> <span data-ttu-id="98221-306">可能的話，它應該在不區分大小寫的方式運作。</span><span class="sxs-lookup"><span data-stu-id="98221-306">If possible, it should operate in a case-insensitive way.</span></span> <span data-ttu-id="98221-307">它應，不過，保留原始的情況下，或更新版本中命令管線中發生的 cmdlet。</span><span class="sxs-lookup"><span data-stu-id="98221-307">It should, however, preserve the original case for cmdlets that occur later in a command or in the pipeline.</span></span>

## <a name="see-also"></a><span data-ttu-id="98221-308">另請參閱</span><span class="sxs-lookup"><span data-stu-id="98221-308">See Also</span></span>

[<span data-ttu-id="98221-309">所需的開發指導方針</span><span class="sxs-lookup"><span data-stu-id="98221-309">Required Development Guidelines</span></span>](./required-development-guidelines.md)

[<span data-ttu-id="98221-310">諮詢開發指導方針</span><span class="sxs-lookup"><span data-stu-id="98221-310">Advisory Development Guidelines</span></span>](./advisory-development-guidelines.md)

[<span data-ttu-id="98221-311">撰寫 Windows PowerShell Cmdlet</span><span class="sxs-lookup"><span data-stu-id="98221-311">Writing a Windows PowerShell Cmdlet</span></span>](./writing-a-windows-powershell-cmdlet.md)
